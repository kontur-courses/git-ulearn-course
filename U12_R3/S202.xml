<?xml version="1.0"?>
<slide id="672cafe4-5d3b-4d26-a88a-5f378c933d36" title="Задание R3-2. Force push with lease" xmlns="https://ulearn.me/schema/v2">

<markdown>
# Введение

Исправлять коммиты, опубликованные в удаленном репозитории, сложнее, чем неопубликованные. Тут уже не обойтись без force push with lease.

# Шаг 1

Текущей веткой должна быть `tracking-feature`. Если это не так — переключись на нее.

# Шаг 2

Замени содержимое `r3.md` на следующее:
```
# R3. Сопоставление веток

&gt; Сопоставление локальных и удаленных веток бывает либо по имени ветки, либо по настройкам отслеживания у локальных веток

&gt; Сопоставление веток обеспечивает работу push без параметров

&gt; Сопоставление веток необходимо для выставления ссылки FETCH_HEAD после fetch, которая используется в команде pull

- `git branch -vv` — вывести список локальных веток с указанием удаленных веток, которые отслеживаются этими локальными ветками
- `git branch -u &lt;remote&gt;/&lt;remote_branch&gt;` — задать текущей локальной ветке новую вышестоящую ветку, т.е. удаленную ветку, которую эта локальная ветка будет отслеживать
- `git branch --unset-upstream` — удалить отслеживание у текущей локальной ветки
- `git push -u origin HEAD` — создать удаленную ветку, соответствующую локальной, сделать так, чтобы локальная ветка отслеживала удаленную ветку, затем добавить изменения из локальной ветки в удаленный репозиторий
- `git checkout &lt;remote_branch&gt;` — создать локальную ветку, отслеживающую удаленную ветку, затем переместить HEAD на нее
- `git pull` = `git pull origin` — получить содержимое основного удаленного репозитория, а затем влить изменения из удаленной ветки в соответствующую локальную ветку
- `git pull --ff-only` — получить содержимое, а затем влить, если возможен fast-forward merge
- `git pull --rebase` — получить содержимое, а затем выполнить rebase локальной ветки на удаленную ветку
- `git pull --rebase --autostash` — сохранить локальные изменения, получить содержимое, выполнить rebase локальной ветки на удаленную ветку, применить сохраненные изменения
- `git config --global push.default simple` — задать simple-режим сопоставления веток при push. Это режим по умолчанию в Git 2.0 и выше
- `git config --global push.autoSetupRemote true` — автонастройка отслеживания при push новых веток
- `&lt;branch&gt;@{u}` — вышестоящая ветка для `&lt;branch&gt;`, например, `main@{u}`
- `HEAD@{u}` = `@{u}` — вышестоящая ветка для текущей ветки
```

# Шаг 3

Добавь изменения в Commit index, а затем выполни amend commit, чтобы не создавать лишний коммит.

&gt; Как сделать amend commit
[в Git Bash?](https://www.google.com/search?q=%D0%9A%D0%B0%D0%BA+%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C+amend+commit+%D0%B2+Git+Bash)
| [в VS Code?](https://www.google.com/search?q=%D0%9A%D0%B0%D0%BA+%D1%81%D0%B4%D0%B5%D0%BB%D0%B0%D1%82%D1%8C+amend+commit+%D0%B2+VS+Code)

# Шаг 4

Обрати внимание, что старый коммит остался видимым, ведь на него ссылается `origin/main`

*Выглядеть должно так:*  
</markdown>
<galleryImages>
    <image>images\r3-2-continue.png</image>
</galleryImages>
<markdown>

# Шаг 5

Если сейчас выполнить push, то он завешится ошибкой, т.к. коммит, на который ссылается `main`, не является потомком коммита, на который ссылается `origin/main`.

Поэтому выполни push с опцией force-with-lease: `git push --force-with-lease`.

# Результат

*Теперь история коммитов должна выглядеть так:*
</markdown>
<galleryImages>
    <image>images\r3-2-finish.png</image>
</galleryImages>

</slide>
