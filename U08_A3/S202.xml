<?xml version="1.0"?>
<slide id="f9524f3e-b095-4af6-ac67-a01773241a5d" title="Задание A3-2. Stash" xmlns="https://ulearn.me/schema/v2">

<markdown>
# Постановка задачи

Бывает, что прямо посреди работы над какой-то функциональностью приходится переключиться на другую работу. В этом случае stash помогает временно сохранить незаконченные изменения, а затем вернуться к ним.

# Шаг 1

Текущей веткой должна быть `picking-feature`. Если это не так — переключись на нее.

# Шаг 2

Работа над разделом A3 продолжается.

Добавь в файл `a3.md` описание вариантов команды cherry-pick. В итоге должно получиться так:
```
# A3. Перенос изменений

&gt; Получить отдельные правки из другой ветки — cherry-pick

&gt; Перенести локальные изменения в новое место — stash

&gt; Переместить коммиты для выстраивания истории в линию — rebase

&gt; Схлопнуть коммиты в один — интерактивный rebase со squash или fixup

- `git cherry-pick &lt;commit&gt;` — применить изменения из указанного коммита к HEAD и сделать коммит
- `git cherry-pick -n &lt;commit&gt;` — применить изменения из указанного коммита, оставив их в индексе
- `git rebase &lt;newbase&gt;` — применить все коммиты от общего родителя до текущего коммита к `&lt;newbase&gt;`
- `git rebase --autostash &lt;newbase&gt;` — сохранить локальные изменения, выполнить rebase, а затем восстановить локальные изменения
- `git rebase -i &lt;newbase&gt;` — применить заново все коммиты, указав действие с каждым коммитом
- `git rebase --continue` — продолжить rebase после разрешения конфликтов
- `git rebase --abort` — отменить rebase
```

# Шаг 3

Сделай коммит с сообщением `Add cherry-pick command to a3.md`.

# Шаг 4

Далее добавь в файл `a3.md` описание вариантов команды stash. В итоге должно получиться так:
```
# A3. Перенос изменений

&gt; Получить отдельные правки из другой ветки — cherry-pick

&gt; Перенести локальные изменения в новое место — stash

&gt; Переместить коммиты для выстраивания истории в линию — rebase

&gt; Схлопнуть коммиты в один — интерактивный rebase со squash или fixup

- `git cherry-pick &lt;commit&gt;` — применить изменения из указанного коммита к HEAD и сделать коммит
- `git cherry-pick -n &lt;commit&gt;` — применить изменения из указанного коммита, оставив их в индексе
- `git stash push -u` — сохранить все изменения в отслеживаемых файлах и новые файлы в виде набора изменений
- `git stash pop` — восстановить последний сохраненный набор изменений и удалить его из списка
- `git stash list` — показать список сохраненных наборов изменений
- `git stash apply --index &lt;stash&gt;` — применить конкретный сохраненный набор изменений
- `git stash drop --index &lt;stash&gt;` — удалить конкретный сохраненный набор изменений
- `git rebase &lt;newbase&gt;` — применить все коммиты от общего родителя до текущего коммита к `&lt;newbase&gt;`
- `git rebase --autostash &lt;newbase&gt;` — сохранить локальные изменения, выполнить rebase, а затем восстановить локальные изменения
- `git rebase -i &lt;newbase&gt;` — применить заново все коммиты, указав действие с каждым коммитом
- `git rebase --continue` — продолжить rebase после разрешения конфликтов
- `git rebase --abort` — отменить rebase
```

# Шаг 5

А вот тут происходит неприятное! Надо прерваться, чтобы быстро внести правки в ветке `main`.

Прежде всего сохрани все локальные изменения в stash через терминал `git stash -u`.

# Шаг 6

Теперь можно заняться правками в ветке `main`!

Переключись на ветку `main`.

Замени содержимое `a2.md` на следующее, в котором появляются новые утверждения:
```
# A2. Пересоздание коммитов

&gt; Нельзя изменить коммит — можно только пересоздать

&gt; Дополнить или переименовать коммит — commit --amend

&gt; Разобрать коммиты — reset --soft

&gt; Отменить коммит другим коммитом — revert

- `git commit --amend` — заменить последний коммит ветки на коммит с дополнительными изменениями и задать новое сообщение к коммиту
- `git commit --amend --no-edit` — заменить последний коммит ветки на коммит с дополнительными изменениями, но с тем же сообщением
- `git reset --hard &lt;commit&gt;` — переместить текущую ветку на `&lt;commit&gt;`, задать индекс и каталог по целевому коммиту `&lt;commit&gt;`
- `git reset &lt;commit&gt;` = `git reset --mixed &lt;commit&gt;` — переместить текущую ветку на `&lt;commit&gt;`, переместить текущую версию каталога, задать индекс по целевому коммиту `&lt;commit&gt;`
- `git reset --soft &lt;commit&gt;` — переместить текущую ветку на `&lt;commit&gt;`, переместить текущие версии каталога и индекса
- `git reset --soft HEAD^1` — отменить последний коммит
- `git revert &lt;commit&gt;` — создать коммит, отменяющий изменения из коммита
- `git revert &lt;commit&gt; -m &lt;parent_number&gt;` — создать коммит, отменяющий изменения одной из объединенных коммитом слияния веток, причем обычно 1 — основная ветка до слияния, 2 — ветка, которая была влита.
```

Закоммить изменения с сообщением `Hotfix. Add new statements to a2.md`.

# Шаг 7

Наконец, можно вернуться к ветке `picking-feature`!

Переключись на ветку `picking-feature`.

А затем верни изменения из stash. Для этого выполни в терминале команду `git stash apply`.

# Шаг 8

Можно было бы продолжить вносить правки в раздел A3, но похоже там все уже хорошо.

Так что просто сделай коммит с сообщением `Add stash command to a3.md`.

# Результат задания

*Теперь история коммитов должна выглядеть так:*
</markdown>
<galleryImages>
    <image>images\a3-2-finish.png</image>
</galleryImages>

</slide>
