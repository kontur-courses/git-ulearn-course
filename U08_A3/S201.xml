<?xml version="1.0"?>
<slide id="583091af-9e3e-404c-8573-99cd4c9710a0" title="Задание A3-1. Rebase to update" xmlns="https://ulearn.me/schema/v2">

<markdown>
# Введение

Когда разработка новой фунциональности в ветке происходит довольно долго, бывает полезно получать свежие правки из основной ветки. Это один из сценариев, где пригождается команда rebase.

Посмотрим, что произойдет если во время добавления нового раздела Гайда в отдельной ветке появится коммит с правками в основной ветке.

# Сохранение прогресса

Сейчас подходящий момент, чтобы сохранить текущий прогресс по выполнению заданий. Для этого достаточно сделать копию папки `ulearn-git-guide`.

Рабочий каталог и репозиторий находятся внутри этой скопированной папки, так что в любой момент можно будет вернуться к сохраненному состоянию. Для этого надо либо переключиться на копию папки, заменить все содержимое папки `ulearn-git-guide` на содержимое папки с сохраненным состоянием.

# Шаг 1

Создай ветку `picking-feature` и переключись на нее.

# Шаг 2

Создай файл `a3.md` со следующим содержимым:
```
# A3. Перенос изменений

&gt; Получить отдельные правки из другой ветки — cherry-pick

&gt; Перенести локальные изменения в новое место — stash

&gt; Переместить коммиты для выстраивания истории в линию — rebase

&gt; Схлопнуть коммиты в один — интерактивный rebase со squash или fixup

- `git rebase &lt;newbase&gt;` — применить все коммиты от общего родителя до текущего коммита к `&lt;newbase&gt;`
- `git rebase --autostash &lt;newbase&gt;` — сохранить локальные изменения, выполнить rebase, а затем восстановить локальные изменения
- `git rebase -i &lt;newbase&gt;` — применить заново все коммиты, указав действие с каждым коммитом
- `git rebase --continue` — продолжить rebase после разрешения конфликтов
- `git rebase --abort` — отменить rebase
```

# Шаг 3

Закоммить изменения с сообщением `Add a3.md`.

# Шаг 4

Пока `picking-feature` находится в разработке, надо выполнить быструю правку в ветке `main`!

Переключись на ветку `main`.

Замени содержимое `s3.md` на следующее, в котором исправляется описание команды создания тега:
```
# S3. Ссылки

&gt; HEAD — текущая ссылка, tag — фиксированная ссылка, branch — движущаяся за HEAD ссылка

&gt; checkout — перемещение на ветку или коммит, reset — перемещение с веткой на коммит

&gt; Видно то, на что есть ссылки, остальное — мусор

- `git tag` — вывести список тегов
- `git tag &lt;tagname&gt;` — создать обычный тег
- `git tag -d &lt;tagname&gt;` — удалить тег
- `git branch --sort=-committerdate` — вывести список локальных веток от новых к старым
- `git branch &lt;branchname&gt;` — создать ветку
- `git branch -f &lt;branchname&gt; &lt;to_commit&gt;` — создать или переместить ветку
- `git branch -M &lt;newbranch&gt;` — переименовать текущую ветку, даже если новое имя уже занято
- `git branch -d &lt;branchname&gt;` — удалить ветку
- `git branch -D &lt;branchname&gt;` — удалить ветку, даже если какие-то коммиты будут скрыты
- `git checkout -d &lt;commit&gt;` или `git switch --detach &lt;commit&gt;` — переместить HEAD на коммит, причем получится detached HEAD
- `git checkout &lt;branch&gt;` или `git switch &lt;branch&gt;` — переместить HEAD на ветку
- `git checkout -b &lt;new_branch&gt;` = `git checkout -b &lt;new_branch&gt; HEAD` или `git switch -c &lt;new_branch&gt;` — создать ветку и перейти на нее
- `git reset --hard &lt;commit&gt;` — переместить HEAD и текущую ветку на `&lt;commit&gt;`
- `git log --oneline --decorate --graph` — вывести историю коммитов от HEAD в виде дерева
- `git log --oneline --decorate --graph --all` — вывести историю коммитов от всех ссылок в виде дерева
- `git log --oneline --decorate --graph --all --reflog` — вывести историю коммитов от всех ссылок и всех недавних положений HEAD в виде дерева
- `git reflog show &lt;ref&gt;` — показать лог действий со ссылкой
- `git reflog` = `git reflog show HEAD` — показать лог действий с HEAD
- `git gc` — удалить ненужные файлы и оптимизировать локальный репозиторий
- `&lt;ref&gt;~N` — 1-ый родитель из N-ого поколения, например, `HEAD~3`
- `&lt;ref&gt;^N` — N-ый родитель предыдущего поколения, например, `HEAD^1^2`
- `&lt;ref&gt;@{N}` — N-ый предшественник по reflog, например, `HEAD@{5}`
```

Закоммить изменения с сообщением `Hotfix. Change tag command description in s3.md`.

# Шаг 5

Переключись назад на ветку `picking-feature`.

# Шаг 6

Замени содержимое `s3.md` на следующее, в котором появляется команда создания аннотированного тега:
```
# S3. Ссылки

&gt; HEAD — текущая ссылка, tag — фиксированная ссылка, branch — движущаяся за HEAD ссылка

&gt; checkout — перемещение на ветку или коммит, reset — перемещение с веткой на коммит

&gt; Видно то, на что есть ссылки, остальное — мусор

- `git tag` — вывести список тегов
- `git tag &lt;tagname&gt;` — создать легковесный тег
- `git tag -a &lt;tagname&gt;` — создать аннотированный тег
- `git tag -d &lt;tagname&gt;` — удалить тег
- `git branch --sort=-committerdate` — вывести список локальных веток от новых к старым
- `git branch &lt;branchname&gt;` — создать ветку
- `git branch -f &lt;branchname&gt; &lt;to_commit&gt;` — создать или переместить ветку
- `git branch -M &lt;newbranch&gt;` — переименовать текущую ветку, даже если новое имя уже занято
- `git branch -d &lt;branchname&gt;` — удалить ветку
- `git branch -D &lt;branchname&gt;` — удалить ветку, даже если какие-то коммиты будут скрыты
- `git checkout -d &lt;commit&gt;` или `git switch --detach &lt;commit&gt;` — переместить HEAD на коммит, причем получится detached HEAD
- `git checkout &lt;branch&gt;` или `git switch &lt;branch&gt;` — переместить HEAD на ветку
- `git checkout -b &lt;new_branch&gt;` = `git checkout -b &lt;new_branch&gt; HEAD` или `git switch -c &lt;new_branch&gt;` — создать ветку и перейти на нее
- `git reset --hard &lt;commit&gt;` — переместить HEAD и текущую ветку на `&lt;commit&gt;`
- `git log --oneline --decorate --graph` — вывести историю коммитов от HEAD в виде дерева
- `git log --oneline --decorate --graph --all` — вывести историю коммитов от всех ссылок в виде дерева
- `git log --oneline --decorate --graph --all --reflog` — вывести историю коммитов от всех ссылок и всех недавних положений HEAD в виде дерева
- `git reflog show &lt;ref&gt;` — показать лог действий со ссылкой
- `git reflog` = `git reflog show HEAD` — показать лог действий с HEAD
- `git gc` — удалить ненужные файлы и оптимизировать локальный репозиторий
- `&lt;ref&gt;~N` — 1-ый родитель из N-ого поколения, например, `HEAD~3`
- `&lt;ref&gt;^N` — N-ый родитель предыдущего поколения, например, `HEAD^1^2`
- `&lt;ref&gt;@{N}` — N-ый предшественник по reflog, например, `HEAD@{5}`
```

# Шаг 7

Закоммить изменения с сообщением `Change s3.md`.

# Шаг 8

Теперь хочется получить последние правки из ветки `main` в ветку `picking-feature`.

Чтобы лучше понять как отработает rebase, установи легковесный тег `old-picking-feature` на текущий коммит.

# Шаг 9

Выполни в терминале rebase `picking-feature` на `main`: `HEAD` уже находится на `picking-feature`, так что просто выполни команду `git rebase main`.

При rebase возникнет конфликт.

# Шаг 10

Первый коммит `Add a3.md` успешно скопирован, а вот `Change s3.md` по понятным причинам порождает конфликты.

Открой в VS Code в боковом меню пункт Source Control и найди там файл `s3.md`. В этом файле есть конфликт, но его легко устранить. Так как в ветке `picking-feature` был правильный текст, нажми `Accept Incoming Change` и сохрани файл.

Добавь `s3.md` в Commit index и выполни команду `git rebase --continue`.

Раз оба коммита были успешно скопированы, rebase на этом будет завершен.
Фанфар по этому поводу не будет, в терминале просто появится об успешном выполнении rebase.

# Шаг 11

Обрати внимание, что в результате rebase были созданы новые коммиты `Add a3.md` и `Change s3.md`. Хоть они похожи на исходные, все же это новые коммиты с новыми хэшами.

Также обрати внимание, что ветка `picking-feature` была перемещена и теперь ссылается на новый коммит. Старые коммиты остались в репозитории, а на последний из них все еще ссылается тег `old-picking-feature`.

# Результат

*Теперь история коммитов должна выглядеть так:*
</markdown>
<galleryImages>
    <image>images\a3-1-finish.png</image>
</galleryImages>

</slide>
